{"version":3,"file":"848.js","mappings":"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","sources":["webpack://frontend/../../../src/shared/lib/encode-uri-path.ts","webpack://frontend/../../../src/shared/lib/is-plain-object.ts","webpack://frontend/../../../../src/shared/lib/page-path/denormalize-page-path.ts","webpack://frontend/../../../../src/shared/lib/page-path/ensure-leading-slash.ts","webpack://frontend/../../../../src/shared/lib/page-path/normalize-path-sep.ts","webpack://frontend/../../../../../src/shared/lib/router/utils/app-paths.ts","webpack://frontend/../../../../../src/shared/lib/router/utils/index.ts","webpack://frontend/../../../../../src/shared/lib/router/utils/is-dynamic.ts","webpack://frontend/../../../../../src/shared/lib/router/utils/sorted-routes.ts","webpack://frontend/../../../src/shared/lib/segment.ts","webpack://frontend/../../../src/shared/lib/utils.ts","webpack://frontend/./node_modules/next/dist/lib/is-error.js","webpack://frontend/./node_modules/next/dist/server/lib/interception-routes.js","webpack://frontend/./node_modules/next/dist/server/route-modules/pages/module.compiled.js","webpack://frontend/./node_modules/@swc/helpers/cjs/_interop_require_default.cjs"],"sourcesContent":["export function encodeURIPath(file: string) {\n  return file\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')\n}\n","export function getObjectClassLabel(value: any): string {\n  return Object.prototype.toString.call(value)\n}\n\nexport function isPlainObject(value: any): boolean {\n  if (getObjectClassLabel(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n\n  /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */\n  return prototype === null || prototype.hasOwnProperty('isPrototypeOf')\n}\n","import { isDynamicRoute } from '../router/utils'\nimport { normalizePathSep } from './normalize-path-sep'\n\n/**\n * Performs the opposite transformation of `normalizePagePath`. Note that\n * this function is not idempotent either in cases where there are multiple\n * leading `/index` for the page. Examples:\n *  - `/index` -> `/`\n *  - `/index/foo` -> `/foo`\n *  - `/index/index` -> `/index`\n */\nexport function denormalizePagePath(page: string) {\n  let _page = normalizePathSep(page)\n  return _page.startsWith('/index/') && !isDynamicRoute(_page)\n    ? _page.slice(6)\n    : _page !== '/index'\n      ? _page\n      : '/'\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","/**\n * For a given page path, this function ensures that there is no backslash\n * escaping slashes in the path. Example:\n *  - `foo\\/bar\\/baz` -> `foo/bar/baz`\n */\nexport function normalizePathSep(path: string): string {\n  return path.replace(/\\\\/g, '/')\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","export { getSortedRoutes, getSortedRouteObjects } from './sorted-routes'\nexport { isDynamicRoute } from './is-dynamic'\n","import {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../../../../server/lib/interception-routes'\n\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/\n\nexport function isDynamicRoute(route: string): boolean {\n  if (isInterceptionRouteAppPath(route)) {\n    route = extractInterceptionRouteInformation(route).interceptedRoute\n  }\n\n  return TEST_ROUTE.test(route)\n}\n","class UrlNode {\n  placeholder: boolean = true\n  children: Map<string, UrlNode> = new Map()\n  slugName: string | null = null\n  restSlugName: string | null = null\n  optionalRestSlugName: string | null = null\n\n  insert(urlPath: string): void {\n    this._insert(urlPath.split('/').filter(Boolean), [], false)\n  }\n\n  smoosh(): string[] {\n    return this._smoosh()\n  }\n\n  private _smoosh(prefix: string = '/'): string[] {\n    const childrenPaths = [...this.children.keys()].sort()\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1)\n    }\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)\n    }\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)\n    }\n\n    const routes = childrenPaths\n      .map((c) => this.children.get(c)!._smoosh(`${prefix}${c}/`))\n      .reduce((prev, curr) => [...prev, ...curr], [])\n\n    if (this.slugName !== null) {\n      routes.push(\n        ...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)\n      )\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1)\n      if (this.optionalRestSlugName != null) {\n        throw new Error(\n          `You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`\n        )\n      }\n\n      routes.unshift(r)\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[...]')!\n          ._smoosh(`${prefix}[...${this.restSlugName}]/`)\n      )\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[[...]]')!\n          ._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)\n      )\n    }\n\n    return routes\n  }\n\n  private _insert(\n    urlPaths: string[],\n    slugNames: string[],\n    isCatchAll: boolean\n  ): void {\n    if (urlPaths.length === 0) {\n      this.placeholder = false\n      return\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`)\n    }\n\n    // The next segment in the urlPaths list\n    let nextSegment = urlPaths[0]\n\n    // Check if the segment matches `[something]`\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1)\n\n      let isOptional = false\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1)\n        isOptional = true\n      }\n\n      if (segmentName.startsWith('…')) {\n        throw new Error(\n          `Detected a three-dot character ('…') at ('${segmentName}'). Did you mean ('...')?`\n        )\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3)\n        isCatchAll = true\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(\n          `Segment names may not start or end with extra brackets ('${segmentName}').`\n        )\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(\n          `Segment names may not start with erroneous periods ('${segmentName}').`\n        )\n      }\n\n      function handleSlug(previousSlug: string | null, nextSlug: string) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(\n              `You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`\n            )\n          }\n        }\n\n        slugNames.forEach((slug) => {\n          if (slug === nextSlug) {\n            throw new Error(\n              `You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`\n            )\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(\n              `You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`\n            )\n          }\n        })\n\n        slugNames.push(nextSlug)\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(\n              `You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`\n            )\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.optionalRestSlugName = segmentName\n          // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n          nextSegment = '[[...]]'\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(\n              `You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`\n            )\n          }\n\n          handleSlug(this.restSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.restSlugName = segmentName\n          // nextSegment is overwritten to [...] so that it can later be sorted specifically\n          nextSegment = '[...]'\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(\n            `Optional route parameters are not yet supported (\"${urlPaths[0]}\").`\n          )\n        }\n        handleSlug(this.slugName, segmentName)\n        // slugName is kept as it can only be one particular slugName\n        this.slugName = segmentName\n        // nextSegment is overwritten to [] so that it can later be sorted specifically\n        nextSegment = '[]'\n      }\n    }\n\n    // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode())\n    }\n\n    this.children\n      .get(nextSegment)!\n      ._insert(urlPaths.slice(1), slugNames, isCatchAll)\n  }\n}\n\nexport function getSortedRoutes(\n  normalizedPages: ReadonlyArray<string>\n): string[] {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode()\n\n  // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n  normalizedPages.forEach((pagePath) => root.insert(pagePath))\n  // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n  return root.smoosh()\n}\n\nexport function getSortedRouteObjects<T>(\n  objects: T[],\n  getter: (obj: T) => string\n): T[] {\n  // We're assuming here that all the pathnames are unique, that way we can\n  // sort the list and use the index as the key.\n  const indexes: Record<string, number> = {}\n  const pathnames: string[] = []\n  for (let i = 0; i < objects.length; i++) {\n    const pathname = getter(objects[i])\n    indexes[pathname] = i\n    pathnames[i] = pathname\n  }\n\n  // Sort the pathnames.\n  const sorted = getSortedRoutes(pathnames)\n\n  // Map the sorted pathnames back to the original objects using the new sorted\n  // index.\n  return sorted.map((pathname) => objects[indexes[pathname]])\n}\n","import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  runtimeConfig?: { [key: string]: any }\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: string[]\n  defaultLocale?: string\n  domainLocales?: DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    getProperError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */ default: function() {\n        return isError;\n    },\n    getProperError: function() {\n        return getProperError;\n    }\n});\nconst _isplainobject = require(\"../shared/lib/is-plain-object\");\nfunction isError(err) {\n    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;\n}\nfunction safeStringify(obj) {\n    const seen = new WeakSet();\n    return JSON.stringify(obj, (_key, value)=>{\n        // If value is an object and already seen, replace with \"[Circular]\"\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return '[Circular]';\n            }\n            seen.add(value);\n        }\n        return value;\n    });\n}\nfunction getProperError(err) {\n    if (isError(err)) {\n        return err;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        // provide better error for case where `throw undefined`\n        // is called in development\n        if (typeof err === 'undefined') {\n            return new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined');\n        }\n        if (err === null) {\n            return new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined');\n        }\n    }\n    return new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + '');\n}\n\n//# sourceMappingURL=is-error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    INTERCEPTION_ROUTE_MARKERS: null,\n    extractInterceptionRouteInformation: null,\n    isInterceptionRouteAppPath: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERCEPTION_ROUTE_MARKERS: function() {\n        return INTERCEPTION_ROUTE_MARKERS;\n    },\n    extractInterceptionRouteInformation: function() {\n        return extractInterceptionRouteInformation;\n    },\n    isInterceptionRouteAppPath: function() {\n        return isInterceptionRouteAppPath;\n    }\n});\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\n    '(..)(..)',\n    '(.)',\n    '(..)',\n    '(...)'\n];\nfunction isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n    let interceptingRoute, marker, interceptedRoute;\n    for (const segment of path.split('/')){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            ;\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n    }\n    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case '(.)':\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === '/') {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n            }\n            break;\n        case '(..)':\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === '/') {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n            }\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n            break;\n        case '(...)':\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = '/' + interceptedRoute;\n            break;\n        case '(..)(..)':\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split('/');\n            if (splitInterceptingRoute.length <= 2) {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n            break;\n        default:\n            throw new Error('Invariant: unexpected marker');\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=interception-routes.js.map","\"use strict\";\nif (process.env.NEXT_RUNTIME === 'edge') {\n    module.exports = require('next/dist/server/route-modules/pages/module.js');\n} else {\n    if (process.env.NODE_ENV === 'development') {\n        module.exports = require('next/dist/compiled/next-server/pages.runtime.dev.js');\n    } else if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/pages-turbo.runtime.prod.js');\n    } else {\n        module.exports = require('next/dist/compiled/next-server/pages.runtime.prod.js');\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map","\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n"],"names":["encodeURIPath","file","split","map","encodeURIComponent","p","join","getObjectClassLabel","value","Object","prototype","toString","call","isPlainObject","getPrototypeOf","hasOwnProperty","denormalizePagePath","page","_page","normalizePathSep","startsWith","isDynamicRoute","slice","ensureLeadingSlash","path","replace","normalizeAppPath","normalizeRscURL","route","reduce","pathname","segment","index","segments","isGroupSegment","length","url","getSortedRouteObjects","getSortedRoutes","TEST_ROUTE","isInterceptionRouteAppPath","extractInterceptionRouteInformation","interceptedRoute","test","UrlNode","insert","urlPath","_insert","filter","Boolean","smoosh","_smoosh","prefix","childrenPaths","children","keys","sort","slugName","splice","indexOf","restSlugName","optionalRestSlugName","routes","get","c","prev","curr","push","placeholder","r","unshift","urlPaths","slugNames","isCatchAll","nextSegment","endsWith","segmentName","isOptional","substring","Error","handleSlug","previousSlug","nextSlug","forEach","slug","has","set","Map","normalizedPages","root","pagePath","objects","getter","indexes","pathnames","i","isParallelRouteSegment","addSearchParamsIfPageSegment","searchParams","isPageSegment","includes","PAGE_SEGMENT_KEY","stringifiedQuery","JSON","stringify","DEFAULT_SEGMENT_KEY","DecodeError","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getLocationOrigin","getURL","isAbsoluteUrl","isResSent","loadGetInitialProps","normalizeRepeatedSlashes","stringifyError","fn","result","used","args","ABSOLUTE_URL_REGEX","protocol","hostname","port","window","location","href","origin","Component","displayName","name","res","finished","headersSent","urlParts","App","ctx","getInitialProps","props","message","performance","every","method","constructor","code","error","stack"],"sourceRoot":""}